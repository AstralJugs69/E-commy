import os
import argparse

# --- Configuration ---

# Directories to completely ignore
IGNORE_DIRS = {
    'node_modules',
    '.git',
    '.vscode',
    '.idea',
    '__pycache__',
    'build',
    'dist',
    'target',
    'vendor',
    '.next',
    'out',
    '.svelte-kit',
    'env', 'venv', '.env', '.venv', # Virtual environments
    'logs',
    'coverage',
    # Add project-specific build/asset dirs if needed
    'assets', 'images', 'img', 'static', 'public' # Common asset folders
}

# Specific files or patterns to ignore by name
IGNORE_FILES = {
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml',
    '.env',
    '.DS_Store',
    # Add specific large data/binary files if known
    '*.log',
    '*.lock', # General lock files (adjust if needed, e.g. keep Gemfile.lock)
    # Add common binary file extensions you absolutely want to skip by name
     '*.png', '*.jpg', '*.jpeg', '*.gif', '*.webp', '*.ico', '*.pdf', '*.zip', '*.gz', '*.tar',
     '*.exe', '*.dll', '*.so', '*.dylib', '*.jar', '*.class',
     '*.mp3', '*.wav', '*.mp4', '*.mov',
     '*.ttf', '*.otf', '*.woff', '*.woff2',
     '*.db', '*.sqlite', '*.sqlite3',
}

# File extensions to attempt to include (focus on common text/code)
# Files NOT matching these extensions (or specific filenames below) will be skipped BEFORE attempting to read.
INCLUDE_EXTENSIONS = {
    # Web Frontend
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    '.js', '.jsx', '.ts', '.tsx', '.vue', '.svelte',
    # Backend
    '.py', '.java', '.rb', '.php', '.cs', '.go', '.rs', '.swift',
    # Scripts & Config
    '.sh', '.bash', '.ps1',
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.md', '.txt', '.rst',
    # SQL
    '.sql',
    # Docker/Git/Common Config (add specific filenames if extensionless)
    'Dockerfile', '.dockerignore', '.gitignore', '.gitattributes',
    'requirements.txt', 'Pipfile', 'pyproject.toml', # Python
    'pom.xml', 'build.gradle', # Java
    '.csproj', '.sln', # C#
    'Gemfile', 'Gemfile.lock', # Ruby (Keep Gemfile.lock despite *.lock pattern)
    'composer.json', 'composer.lock', # PHP
    # Add other TEXT file extensions relevant to your project
}

# --- Script Logic ---

def should_ignore(path, root_dir):
    """Checks if a file or directory should be ignored based on rules."""
    relative_path = os.path.relpath(path, root_dir)
    parts = relative_path.split(os.sep)

    # Check ignored directories
    for part in parts:
        if part in IGNORE_DIRS:
            return True, f"In ignored directory '{part}'"

    filename = parts[-1]

    # Check ignored file names/patterns
    import fnmatch
    for pattern in IGNORE_FILES:
        # Special case: Ensure Gemfile.lock/composer.lock etc are NOT ignored by '*.lock'
        is_specific_lock = pattern == '*.lock' and filename in ('Gemfile.lock', 'Pipfile.lock', 'composer.lock', 'poetry.lock') # Add others if needed
        if not is_specific_lock and fnmatch.fnmatch(filename, pattern):
             return True, f"Matches ignored pattern '{pattern}'"

    # Ignore hidden files/directories unless explicitly included
    if filename.startswith('.') and filename not in INCLUDE_EXTENSIONS and os.path.splitext(filename)[1] not in INCLUDE_EXTENSIONS:
         if os.path.isfile(path):
             return True, "Is hidden file not in INCLUDE_EXTENSIONS"
         elif os.path.isdir(path) and filename not in IGNORE_DIRS:
              return True, "Is hidden directory not in IGNORE_DIRS"

    return False, ""


def process_project(root_dir, output_file):
    """Walks directory, appends text file contents to the output markdown file."""
    count = 0
    ignored_count = 0
    binary_skipped_count = 0
    error_count = 0

    output_abs_path = os.path.abspath(output_file)

    with open(output_file, 'w', encoding='utf-8') as outfile:
        outfile.write(f"# Project Codebase Summary: {os.path.basename(root_dir)}\n\n")
        outfile.write("Generated by `create_code_summary_simple.py`.\n")
        outfile.write("This file concatenates suspected text/code files. Files ignored by rules or detected as binary are skipped.\n\n")

        for dirpath, dirnames, filenames in os.walk(root_dir, topdown=True):
            # Filter ignored directories
            dirs_to_remove = set()
            for d in dirnames:
                dir_full_path = os.path.join(dirpath, d)
                ignore_dir, reason_dir = should_ignore(dir_full_path, root_dir)
                if ignore_dir:
                    dirs_to_remove.add(d)
            dirnames[:] = [d for d in dirnames if d not in dirs_to_remove]
            ignored_count += len(dirs_to_remove)

            # Process files
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                relative_path = os.path.relpath(file_path, root_dir)

                # Skip the output file itself
                if os.path.abspath(file_path) == output_abs_path:
                    continue

                # Check ignore rules
                ignore_file, reason_file = should_ignore(file_path, root_dir)
                if ignore_file:
                    # print(f"Ignoring file: {relative_path} ({reason_file})") # Optional: uncomment for more detail
                    ignored_count += 1
                    continue

                # Check if extension or filename is in our include list
                _, ext = os.path.splitext(filename)
                basename = os.path.basename(filename)
                if ext.lower() not in INCLUDE_EXTENSIONS and basename not in INCLUDE_EXTENSIONS:
                    # print(f"Skipping (extension not included): {relative_path}") # Optional: uncomment for more detail
                    ignored_count += 1
                    continue

                # Try reading the file as text
                try:
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()

                    # Append to output file
                    outfile.write(f"## File: `{relative_path}`\n\n")
                    outfile.write("```\n") # Generic code block
                    # Ensure content ends with a newline before the closing fence
                    if content and not content.endswith('\n'):
                         content += '\n'
                    outfile.write(content)
                    outfile.write("```\n\n")
                    count += 1

                except UnicodeDecodeError:
                    # print(f"Skipping (binary detected): {relative_path}") # Optional: uncomment for more detail
                    binary_skipped_count += 1
                    continue # Skip this file
                except FileNotFoundError:
                     print(f"Error: File not found (possible symlink issue?): {relative_path}")
                     error_count += 1
                except Exception as e:
                    print(f"Error reading file {relative_path}: {e}")
                    error_count += 1

    print("-" * 50)
    print(f"Processing Complete.")
    print(f"Output file: {output_file}")
    print(f"Text files processed: {count}")
    print(f"Files/Dirs ignored by rules/extension: {ignored_count}")
    print(f"Files skipped (detected as binary): {binary_skipped_count}")
    print(f"File read errors: {error_count}")
    print("-" * 50)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate a simple Markdown summary of a project's text codebase.")
    parser.add_argument("root_dir", nargs='?', default='.', help="The root directory of the project (default: current directory).")
    parser.add_argument("-o", "--output", default="project_codebase_simple.md", help="The name of the output Markdown file (default: project_codebase_simple.md).")
    args = parser.parse_args()

    root_directory = os.path.abspath(args.root_dir)
    output_filename = os.path.join(root_directory, args.output) # Place output in root dir by default

    if not os.path.isdir(root_directory):
        print(f"Error: Root directory '{root_directory}' not found or is not a directory.")
    else:
        print(f"Starting codebase scan in: {root_directory}")
        print(f"Output will be saved to: {output_filename}")
        process_project(root_directory, output_filename)